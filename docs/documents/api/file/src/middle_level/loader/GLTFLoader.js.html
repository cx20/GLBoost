<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/middle_level/loader/GLTFLoader.js | glboost</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="A New WebGL Rendering Library for 3D Graphics Geeks"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="glboost"><meta property="twitter:description" content="A New WebGL Rendering Library for 3D Graphics Geeks"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/emadurandal/GLBoost"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#auxiliaries">auxiliaries</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/auxiliaries/AnimationPlayer.js~AnimationPlayer.html">AnimationPlayer</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-auxiliaries-camera-controllers">low_level/auxiliaries/camera_controllers</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/auxiliaries/camera_controllers/L_CameraController.js~L_CameraController.html">L_CameraController</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/auxiliaries/camera_controllers/L_WalkThroughCameraController.js~L_WalkThroughCameraController.html">L_WalkThroughCameraController</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-components">low_level/components</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/components/AnimationComponent.js~AnimationComponent.html">AnimationComponent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/components/SceneGraphComponent.js~SceneGraphComponent.html">SceneGraphComponent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/components/TransformComponent.js~TransformComponent.html">TransformComponent</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-core">low_level/core</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/core/Component.js~Component.html">Component</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/core/ComponentRepository.js~ComponentRepository.html">ComponentRepository</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/core/Entity.js~Entity.html">Entity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/core/EntityRepository.js~EntityRepository.html">EntityRepository</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/core/GLBoostLowContext.js~GLBoostLowContext.html">GLBoostLowContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/core/GLBoostObject.js~GLBoostObject.html">GLBoostObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/core/GLBoostSystem.js~GLBoostSystem.html">GLBoostSystem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/core/GLContext.js~GLContext.html">GLContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/core/GLExtensionsManager.js~GLExtensionsManager.html">GLExtensionsManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/core/L_GLBoostMonitor.js~L_GLBoostMonitor.html">L_GLBoostMonitor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/core/MemoryManager.js~MemoryManager.html">MemoryManager</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-elements">low_level/elements</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/elements/L_Element.js~L_Element.html">L_Element</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-elements-cameras">low_level/elements/cameras</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/elements/cameras/L_AbstractCamera.js~L_AbstractCamera.html">L_AbstractCamera</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/elements/cameras/L_FrustumCamera.js~L_FrustumCamera.html">L_FrustumCamera</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/elements/cameras/L_OrthoCamera.js~L_OrthoCamera.html">L_OrthoCamera</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/elements/cameras/L_PerspectiveCamera.js~L_PerspectiveCamera.html">L_PerspectiveCamera</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-geometries">low_level/geometries</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/geometries/BlendShapeGeometry.js~BlendShapeGeometry.html">BlendShapeGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/geometries/Geometry.js~Geometry.html">Geometry</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-impl">low_level/impl</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/impl/GLContextImpl.js~GLContextImpl.html">GLContextImpl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/impl/GLContextWebGL1Impl.js~GLContextWebGL1Impl.html">GLContextWebGL1Impl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/impl/GLContextWebGL2Impl.js~GLContextWebGL2Impl.html">GLContextWebGL2Impl</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-materials">low_level/materials</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/materials/ClassicMaterial.js~ClassicMaterial.html">ClassicMaterial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/materials/L_AbstractMaterial.js~L_AbstractMaterial.html">L_AbstractMaterial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/materials/PBRMetallicRoughnessMaterial.js~PBRMetallicRoughnessMaterial.html">PBRMetallicRoughnessMaterial</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-math">low_level/math</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/math/AABB.js~AABB.html">AABB</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/math/MathClassUtil.js~MathClassUtil.html">MathClassUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/math/MathUtil.js~MathUtil.html">MathUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/math/Matrix33.js~Matrix33.html">Matrix33</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/math/Matrix44.js~Matrix44.html">Matrix44</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/math/Quaternion.js~Quaternion.html">Quaternion</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/math/Vector2.js~Vector2.html">Vector2</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/math/Vector3.js~Vector3.html">Vector3</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/math/Vector4.js~Vector4.html">Vector4</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-misc">low_level/misc</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/misc/AnimationUtil.js~AnimationUtil.html">AnimationUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/misc/ArrayUtil.js~ArrayUtil.html">ArrayUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/misc/DataUtil.js~DataUtil.html">DataUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/misc/Hash.js~Hash.html">Hash</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/misc/InputUtil.js~InputUtil.html">InputUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/misc/MiscUtil.js~MiscUtil.html">MiscUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/misc/TypedArrayWrapper.js~TypedArrayWrapper.html">TypedArrayWrapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IsUtil">IsUtil</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-primitives">low_level/primitives</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/primitives/Arrow.js~Arrow.html">Arrow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/primitives/Axis.js~Axis.html">Axis</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/primitives/Cube.js~Cube.html">Cube</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/primitives/CubeAbsolute.js~CubeAbsolute.html">CubeAbsolute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/primitives/Grid.js~Grid.html">Grid</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/primitives/JointPrimitive.js~JointPrimitive.html">JointPrimitive</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/primitives/Line.js~Line.html">Line</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/primitives/Particle.js~Particle.html">Particle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/primitives/Plane.js~Plane.html">Plane</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/primitives/Screen.js~Screen.html">Screen</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/primitives/Sphere.js~Sphere.html">Sphere</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-shaders">low_level/shaders</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/shaders/Shader.js~Shader.html">Shader</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#low-level-textures">low_level/textures</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/textures/AbstractTexture.js~AbstractTexture.html">AbstractTexture</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/textures/CubeTexture.js~CubeTexture.html">CubeTexture</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/textures/InternalDataTexture.js~InternalDataTexture.html">InternalDataTexture</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/textures/MutableTexture.js~MutableTexture.html">MutableTexture</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/textures/PhinaTexture.js~PhinaTexture.html">PhinaTexture</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/low_level/textures/Texture.js~Texture.html">Texture</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level">middle_level</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/Renderer.js~Renderer.html">Renderer</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-core">middle_level/core</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/core/GLBoostMiddleContext.js~GLBoostMiddleContext.html">GLBoostMiddleContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/core/M_GLBoostMonitor.js~M_GLBoostMonitor.html">M_GLBoostMonitor</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-draw-kickers">middle_level/draw_kickers</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/draw_kickers/DrawKickerWorld.js~DrawKickerWorld.html">DrawKickerWorld</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-elements">middle_level/elements</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/M_Element.js~M_Element.html">M_Element</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/M_Group.js~M_Group.html">M_Group</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/M_Scene.js~M_Scene.html">M_Scene</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-elements-cameras">middle_level/elements/cameras</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/cameras/M_AbstractCamera.js~M_AbstractCamera.html">M_AbstractCamera</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/cameras/M_FrustumCamera.js~M_FrustumCamera.html">M_FrustumCamera</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/cameras/M_OrthoCamera.js~M_OrthoCamera.html">M_OrthoCamera</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/cameras/M_PerspectiveCamera.js~M_PerspectiveCamera.html">M_PerspectiveCamera</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-elements-gizmos">middle_level/elements/gizmos</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/gizmos/M_AABBGizmo.js~M_AABBGizmo.html">M_AABBGizmo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/gizmos/M_AxisGizmo.js~M_AxisGizmo.html">M_AxisGizmo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/gizmos/M_DirectionalLightGizmo.js~M_DirectionalLightGizmo.html">M_DirectionalLightGizmo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/gizmos/M_Gizmo.js~M_Gizmo.html">M_Gizmo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/gizmos/M_GridGizmo.js~M_GridGizmo.html">M_GridGizmo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/gizmos/M_HeightLineGizmo.js~M_HeightLineGizmo.html">M_HeightLineGizmo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/gizmos/M_JointGizmo.js~M_JointGizmo.html">M_JointGizmo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/gizmos/M_OutlineGizmo.js~M_OutlineGizmo.html">M_OutlineGizmo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/gizmos/M_PointLightGizmo.js~M_PointLightGizmo.html">M_PointLightGizmo</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-elements-lights">middle_level/elements/lights</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/lights/M_AbstractLight.js~M_AbstractLight.html">M_AbstractLight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/lights/M_AmbientLight.js~M_AmbientLight.html">M_AmbientLight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/lights/M_DirectionalLight.js~M_DirectionalLight.html">M_DirectionalLight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/lights/M_PointLight.js~M_PointLight.html">M_PointLight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/lights/M_SpotLight.js~M_SpotLight.html">M_SpotLight</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-elements-meshes">middle_level/elements/meshes</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/meshes/M_Mesh.js~M_Mesh.html">M_Mesh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/meshes/M_ScreenMesh.js~M_ScreenMesh.html">M_ScreenMesh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/meshes/M_SkeletalMesh.js~M_SkeletalMesh.html">M_SkeletalMesh</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-elements-skeletons">middle_level/elements/skeletons</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/skeletons/JointGizmoUpdater.js~JointGizmoUpdater.html">JointGizmoUpdater</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/elements/skeletons/M_Joint.js~M_Joint.html">M_Joint</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-expressions">middle_level/expressions</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/expressions/Expression.js~Expression.html">Expression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/expressions/RenderPass.js~RenderPass.html">RenderPass</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-geometries">middle_level/geometries</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/geometries/M_SkeletalGeometry.js~M_SkeletalGeometry.html">M_SkeletalGeometry</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-loader">middle_level/loader</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/loader/GLBoostGLTFLoaderExtension.js~GLBoostGLTFLoaderExtension.html">GLBoostGLTFLoaderExtension</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/loader/GLTF2Exporter.js~GLTF2Exporter.html">GLTF2Exporter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/loader/GLTF2Loader.js~GLTF2Loader.html">GLTF2Loader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/loader/GLTFLoader.js~GLTFLoader.html">GLTFLoader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/loader/ModelConverter.js~ModelConverter.html">ModelConverter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/loader/ObjLoader.js~ObjLoader.html">ObjLoader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-formatDetector">formatDetector</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-plugins">middle_level/plugins</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/plugins/EffekseerElement.js~EffekseerElement.html">EffekseerElement</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middle-level-shaders">middle_level/shaders</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/BlendShapeShader.js~BlendShapeShaderSource.html">BlendShapeShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/BlinnPhongShader.js~BlinnPhongShader.html">BlinnPhongShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/BlinnPhongShader.js~BlinnPhongShaderSource.html">BlinnPhongShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/DecalShader.js~DecalShader.html">DecalShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/DecalShader.js~DecalShaderSource.html">DecalShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/DepthDisplayShader.js~DepthDisplayShader.html">DepthDisplayShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/DepthDisplayShader.js~DepthDisplayShaderSource.html">DepthDisplayShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/EnvironmentMapShader.js~EnvironmentMapShader.html">EnvironmentMapShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/EnvironmentMapShader.js~EnvironmentMapShaderSource.html">EnvironmentMapShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/FragmentSimpleShader.js~FragmentSimpleShader.html">FragmentSimpleShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/FragmentSimpleShader.js~FragmentSimpleShaderSource.html">FragmentSimpleShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/FreeShader.js~FreeShader.html">FreeShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/HalfLambertAndWrapLightingShader.js~HalfLambertAndWrapLightingShader.html">HalfLambertAndWrapLightingShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/HalfLambertAndWrapLightingShader.js~HalfLambertAndWrapLightingShaderSource.html">HalfLambertAndWrapLightingShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/HalfLambertShader.js~HalfLambertShader.html">HalfLambertShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/HalfLambertShader.js~HalfLambertShaderSource.html">HalfLambertShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/LambertShader.js~LambertShader.html">LambertShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/LambertShader.js~LambertShaderSource.html">LambertShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/PBRPrincipledShader.js~PBRPrincipledShader.html">PBRPrincipledShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/PBRPrincipledShader.js~PBRPrincipledShaderSource.html">PBRPrincipledShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/ParticleShader.js~ParticleShaderSource.html">ParticleShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/PassThroughShader.js~PassThroughShader.html">PassThroughShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/PassThroughShader.js~PassThroughShaderSource.html">PassThroughShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/PhongShader.js~PhongShader.html">PhongShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/PhongShader.js~PhongShaderSource.html">PhongShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/SkeletalShader.js~SkeletalShaderSource.html">SkeletalShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/VertexWorldShader.js~VertexWorldShaderSource.html">VertexWorldShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/VertexWorldShadowShader.js~VertexWorldShadowShaderSource.html">VertexWorldShadowShaderSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/WireframeShader.js~WireframeShader.html">WireframeShader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/middle_level/shaders/WireframeShader.js~WireframeShaderSource.html">WireframeShaderSource</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/middle_level/loader/GLTFLoader.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import GLBoost from &apos;../../globals&apos;;
import M_OrthoCamera from &apos;../elements/cameras/M_OrthoCamera&apos;;
import M_PerspectiveCamera from &apos;../elements/cameras/M_PerspectiveCamera&apos;;
import M_SkeletalMesh from &apos;../elements/meshes/M_SkeletalMesh&apos;;
import M_Mesh from &apos;../elements/meshes/M_Mesh&apos;;
import DecalShader from &apos;../shaders/DecalShader&apos;;
import LambertShader from &apos;../shaders/LambertShader&apos;;
import PhongShader from &apos;../shaders/PhongShader&apos;;
import FreeShader from &apos;../shaders/FreeShader&apos;;
import Vector3 from &apos;../../low_level/math/Vector3&apos;;
import Vector2 from &apos;../../low_level/math/Vector2&apos;;
import Vector4 from &apos;../../low_level/math/Vector4&apos;;
import Matrix44 from &apos;../../low_level/math/Matrix44&apos;;
import Quaternion from &apos;../../low_level/math/Quaternion&apos;;
import ArrayUtil from &apos;../../low_level/misc/ArrayUtil&apos;;
import DataUtil from &apos;../../low_level/misc/DataUtil&apos;;
import M_Group from &apos;../elements/M_Group&apos;;
import MathUtil from &quot;../../low_level/math/MathUtil&quot;;
import MathClassUtil from &apos;../../low_level/math/MathClassUtil&apos;;
import ClassicMaterial from &apos;../../low_level/materials/ClassicMaterial&apos;;


let singleton = Symbol();
let singletonEnforcer = Symbol();

/**
 * This is a loader class of glTF file format. You can see more detail of glTF format at https://github.com/KhronosGroup/glTF .
 */
export default class GLTFLoader {

  /**
   * The constructor of GLTFLoader class. But you cannot use this constructor directly because of this class is a singleton class. Use getInstance() static method.
   * @param enforcer a Symbol to forbid calling this constructor directly
   */
  constructor(enforcer: Symbol) {
    if (enforcer !== singletonEnforcer) {
      throw new Error(&quot;This is a Singleton class. get the instance using &apos;getInstance&apos; static method.&quot;);
    }
  }

  /**
   * The static method to get singleton instance of this class.&lt;br&gt;
   * @return The singleton instance of GLTFLoader class
   */
  static getInstance(): GLTFLoader {
    if (!this[singleton]) {
      this[singleton] = new GLTFLoader(singletonEnforcer);
    }
    return this[singleton];
  }

  getDefaultShader(options) {
    let defaultShader = null;

    if (options &amp;&amp; typeof options.defaultShaderClass !== &quot;undefined&quot;) {
      if (typeof options.defaultShaderClass === &quot;string&quot;) {
        defaultShader = GLBoost[options.defaultShaderClass];
      } else {
        defaultShader = options.defaultShaderClass;
      }
    }

    return defaultShader;
  }

  getOptions(defaultOptions, json, options) {
    if (json.asset &amp;&amp; json.asset.extras &amp;&amp; json.asset.extras.loadOptions) {
      for (let optionName in json.asset.extras.loadOptions) {
        defaultOptions[optionName] = json.asset.extras.loadOptions[optionName];
      }
    }

    for (let optionName in options) {
      defaultOptions[optionName] = options[optionName];
    }

    if (defaultOptions.loaderExtension &amp;&amp; typeof defaultOptions.loaderExtension === &quot;string&quot;) {
      defaultOptions.loaderExtension = GLBoost[options.loaderExtension].getInstance();
    }

    if (defaultOptions.statesOfElements) {
      for (let state of defaultOptions.statesOfElements) {
        if (state.shaderClass &amp;&amp; typeof state.shaderClass === &quot;string&quot;) {
          state.shaderClass = GLBoost[state.shaderClass];
        }
      }
    }

    if (options &amp;&amp; typeof options.defaultMaterial !== &quot;undefined&quot;) {
      if (typeof options.defaultMaterial === &quot;string&quot;) {
        defaultOptions.defaultMaterial = GLBoost[options.defaultMaterial];
      } else {
        defaultOptions.defaultMaterial = options.defaultMaterial;
      }
    }

    if (defaultOptions.defaultMaterial != null &amp;&amp; defaultOptions.defaultMaterial.name.indexOf(&apos;PBR&apos;) !== -1) {
      defaultOptions.defaultShaderClass = defaultOptions.defaultMaterial.shaderClass;
    } else if (options &amp;&amp; typeof options.defaultShaderClass !== &quot;undefined&quot;) {
      if (typeof options.defaultShaderClass === &quot;string&quot;) {
        defaultOptions.defaultShaderClass = GLBoost[options.defaultShaderClass];
      } else {
        defaultOptions.defaultShaderClass = options.defaultShaderClass;
      }
    }

    return defaultOptions;
  }

  /**
   * the method to load glTF file.
   * @param glBoostContext - glBoostContext instance
   * @param url - url of glTF file
   * @param options - option data for loading
   * @return a promise object
   */
  loadGLTF(glBoostContext: glBoostContext, url: string, options: Object): Promise {
    let defaultOptions = {
      files: { 
        //        &quot;foo.gltf&quot;: content of file as ArrayBuffer, 
        //        &quot;foo.bin&quot;: content of file as ArrayBuffer, 
        //        &quot;boo.png&quot;: content of file as ArrayBuffer 
      },
      loaderExtension: null,
      isNeededToMultiplyAlphaToColorOfPixelOutput: true,
      isTextureImageToLoadPreMultipliedAlphaAsDefault: false,
      isExistJointGizmo: false,
      isBlend: false,
      isDepthTest: true,
      defaultMaterial: ClassicMaterial,
      defaultShaderClass: null,
      isMeshTransparentAsDefault: false,
      ignoreMeshList: [],
      defaultStates: {
        states: {
          enable: [
            // 3042,  // BLEND
          ],
          functions: {
            //&quot;blendFuncSeparate&quot;: [1, 0, 1, 0],
          }
        },
        isTransparent: true,
        opacity: 1.0,
        shaderClass: DecalShader, // LambertShader // PhongShader
        isTextureImageToLoadPreMultipliedAlpha: false,
        globalStatesUsage: GLBoost.GLOBAL_STATES_USAGE_IGNORE // GLBoost.GLOBAL_STATES_USAGE_DO_NOTHING // GLBoost.GLOBAL_STATES_USAGE_INCLUSIVE // GLBoost.GLOBAL_STATES_USAGE_EXCLUSIVE
      },
      statesOfElements: [
        {
          targets: [], //[&quot;name_foo&quot;, &quot;name_boo&quot;],
          specifyMethod: GLBoost.QUERY_TYPE_USER_FLAVOR_NAME, // GLBoost.QUERY_TYPE_INSTANCE_NAME // GLBoost.QUERY_TYPE_INSTANCE_NAME_WITH_USER_FLAVOR
          states: {
            enable: [
              // 3042,  // BLEND
            ],
            functions: {
              //&quot;blendFuncSeparate&quot;: [1, 0, 1, 0],
            }
          },
          isTransparent: true,
          opacity: 1.0,
          shaderClass: DecalShader, // LambertShader // PhongShader
          isTextureImageToLoadPreMultipliedAlpha: false,
          globalStatesUsage: GLBoost.GLOBAL_STATES_USAGE_IGNORE // GLBoost.GLOBAL_STATES_USAGE_DO_NOTHING // GLBoost.GLOBAL_STATES_USAGE_INCLUSIVE // GLBoost.GLOBAL_STATES_USAGE_EXCLUSIVE
        }
      ]
    };

    this._materials = [];

    let mustBeReadFromFile = false;
    if (options &amp;&amp; options.files) {
      for (let fileName in options.files) {
        const splitted = fileName.split(&apos;.&apos;);
        const fileExtension = splitted[splitted.length - 1];

        if (fileExtension === &apos;gltf&apos; || fileExtension === &apos;glb&apos;) {
          return new Promise((resolve, response)=&gt;{
            this.checkArrayBufferOfGltf(options.files[fileName], null, options, defaultOptions, glBoostContext, resolve);
          }, (reject, error)=&gt;{
    
          });
        }
      }      
    }

    return DataUtil.loadResourceAsync(url, true,
      (resolve, response)=&gt;{
        var arrayBuffer = response;

        this.checkArrayBufferOfGltf(arrayBuffer, url, options, defaultOptions, glBoostContext, resolve);
      }, (reject, error)=&gt;{

      }
    );

  }

  checkArrayBufferOfGltf(arrayBuffer, url, options, defaultOptions, glBoostContext, resolve) {
    let dataView = new DataView(arrayBuffer, 0, 20);
    let isLittleEndian = true;
    // Magic field
    let magicStr = &apos;&apos;;
    magicStr += String.fromCharCode(dataView.getUint8(0, isLittleEndian));
    magicStr += String.fromCharCode(dataView.getUint8(1, isLittleEndian));
    magicStr += String.fromCharCode(dataView.getUint8(2, isLittleEndian));
    magicStr += String.fromCharCode(dataView.getUint8(3, isLittleEndian));
    if (magicStr !== &apos;glTF&apos;) {
      this.loadAsTextJson(arrayBuffer, url, options, defaultOptions, glBoostContext, resolve);
    }
    else {
      this.loadAsBinaryJson(dataView, isLittleEndian, arrayBuffer, options, defaultOptions, glBoostContext, resolve);
    }
  }

  loadAsBinaryJson(dataView, isLittleEndian, arrayBuffer, options, defaultOptions, glBoostContext, resolve) {
    let gltfVer = dataView.getUint32(4, isLittleEndian);
    if (gltfVer !== 1) {
      reject(&apos;invalid version field in this binary glTF file.&apos;);
    }
    let lengthOfThisFile = dataView.getUint32(8, isLittleEndian);
    let lengthOfContent = dataView.getUint32(12, isLittleEndian);
    let contentFormat = dataView.getUint32(16, isLittleEndian);
    if (contentFormat !== 0) { // 0 means JSON format
      reject(&apos;invalid contentFormat field in this binary glTF file.&apos;);
    }
    let arrayBufferContent = arrayBuffer.slice(20, lengthOfContent + 20);
    let gotText = DataUtil.arrayBufferToString(arrayBufferContent);
    let json = JSON.parse(gotText);
    let arrayBufferBinary = arrayBuffer.slice(20 + lengthOfContent);
    let glTFVer = this._checkGLTFVersion(json);
    options = this.getOptions(defaultOptions, json, options);
    const defaultShader = options.defaultShaderClass;
    this._loadResourcesAndScene(glBoostContext, arrayBufferBinary, null, json, defaultShader, glTFVer, resolve, options);
    return { options, defaultShader };
  }

  loadAsTextJson(arrayBuffer, url, options, defaultOptions, glBoostContext, resolve) {
    let gotText = DataUtil.arrayBufferToString(arrayBuffer);

    let basePath = &apos;&apos;;
    if (url) {
      let partsOfPath = url.split(&apos;/&apos;);
      for (let i = 0; i &lt; partsOfPath.length - 1; i++) {
        basePath += partsOfPath[i] + &apos;/&apos;;
      }  
    } else {
      basePath = null;
    }

    let json = JSON.parse(gotText);
    let glTFVer = this._checkGLTFVersion(json);
    options = this.getOptions(defaultOptions, json, options);
    const defaultShader = options.defaultShaderClass;
    this._loadResourcesAndScene(glBoostContext, null, basePath, json, defaultShader, glTFVer, resolve, options);
    return { options, defaultShader };
  }

  _checkGLTFVersion(json) {
    let glTFVer = 1.0;
    if (json.asset &amp;&amp; json.asset.version) {
      glTFVer = parseFloat(json.asset.version);
    }
    return glTFVer;
  }

  _loadResourcesAndScene(glBoostContext, arrayBufferBinary, basePath, json, defaultShader, glTFVer, resolve, options) {
    let shadersJson = json.shaders;
    let shaders = {};
    let buffers = {};
    let textures = {};
    let promisesToLoadResources = [];

    // Shaders Async load
    for (let shaderName in shadersJson) {
      shaders[shaderName] = {};

      let shaderJson = shadersJson[shaderName];
      let shaderType = shaderJson.type;
      if (typeof shaderJson.extensions !== &apos;undefined&apos; &amp;&amp; typeof shaderJson.extensions.KHR_binary_glTF !== &apos;undefined&apos;) {
        shaders[shaderName].shaderText = this._accessBinaryAsShader(shaderJson.extensions.KHR_binary_glTF.bufferView, json, arrayBufferBinary);
        shaders[shaderName].shaderType = shaderType;
        continue;
      }

      let shaderUri = shaderJson.uri;

      if (options.files) {
        const splitted = shaderUri.split(&apos;/&apos;);
        const filename = splitted[splitted.length - 1];
        if (options.files[filename]) {
          const arrayBuffer = options.files[filename];
          shaders[shaderName].shaderText = DataUtil.arrayBufferToString(arrayBuffer);
          shaders[shaderName].shaderType = shaderType;
          continue;
        }
      }

      if (shaderUri.match(/^data:/)) {
        promisesToLoadResources.push(
          new Promise((fulfilled, rejected) =&gt; {
            let arrayBuffer = DataUtil.base64ToArrayBuffer(shaderUri);
            shaders[shaderName].shaderText = DataUtil.arrayBufferToString(arrayBuffer);
            shaders[shaderName].shaderType = shaderType;
            fulfilled();
          })
        );
      } else {
        shaderUri = basePath + shaderUri;
        promisesToLoadResources.push(
          DataUtil.loadResourceAsync(shaderUri, false,
            (resolve, response)=&gt;{
              shaders[shaderName].shaderText = response;
              shaders[shaderName].shaderType = shaderType;
              resolve();
            },
            (reject, error)=&gt;{

            }
          )
        );
      }
    }

    // Buffers Async load
    for (let bufferName in json.buffers) {
      let bufferInfo = json.buffers[bufferName];
      const splitted = bufferInfo.uri.split(&apos;/&apos;);
      const filename = splitted[splitted.length - 1];
      if (bufferInfo.uri.match(/^data:application\/octet-stream;base64,/)) {
        promisesToLoadResources.push(
          new Promise((fulfilled, rejected) =&gt; {
            let arrayBuffer = DataUtil.base64ToArrayBuffer(bufferInfo.uri);
            buffers[bufferName] = arrayBuffer;
            fulfilled();
          })
        );
      } else if (bufferInfo.uri === &apos;&apos; || bufferInfo.uri === &apos;data:,&apos;) {
        buffers[bufferName] = arrayBufferBinary;
      } else if (options.files &amp;&amp; options.files[filename]) {
        const arrayBuffer = options.files[filename];
        buffers[bufferName] = arrayBuffer;
      } else {
        promisesToLoadResources.push(
          DataUtil.loadResourceAsync(basePath + bufferInfo.uri, true,
            (resolve, response)=&gt;{
              buffers[bufferName] = response;
              resolve();
            },
            (reject, error)=&gt;{

            }
          )
        );
      }
    }

    // Textures Async load
    for (let textureName in json.textures) {
      let textureJson = json.textures[textureName];
      let imageJson = json.images[textureJson.source];
      let samplerJson = json.samplers[textureJson.sampler];

      let textureUri = null;

      if (typeof imageJson.extensions !== &apos;undefined&apos; &amp;&amp; typeof imageJson.extensions.KHR_binary_glTF !== &apos;undefined&apos;) {
        textureUri = this._accessBinaryAsImage(imageJson.extensions.KHR_binary_glTF.bufferView, json, arrayBufferBinary, imageJson.extensions.KHR_binary_glTF.mimeType);
      } else {
        let imageFileStr = imageJson.uri;
        const splitted = imageFileStr.split(&apos;/&apos;);
        const filename = splitted[splitted.length - 1];
        if (options.files &amp;&amp; options.files[filename]) {
          const arrayBuffer = options.files[filename];
          const splitted = filename.split(&apos;.&apos;);
          const fileExtension = splitted[splitted.length - 1];
          textureUri = this._accessArrayBufferAsImage(arrayBuffer, fileExtension);
        } else if (imageFileStr.match(/^data:/)) {
          textureUri = imageFileStr;
        } else {
          textureUri = basePath + imageFileStr;
        }
      }

      let texture = glBoostContext.createTexture(null, textureName, {
        &apos;TEXTURE_MAG_FILTER&apos;: samplerJson.magFilter,
        &apos;TEXTURE_MIN_FILTER&apos;: samplerJson.minFilter,
        &apos;TEXTURE_WRAP_S&apos;: samplerJson.wrapS,
        &apos;TEXTURE_WRAP_T&apos;: samplerJson.wrapT
      });
      
      if (options.loaderExtension &amp;&amp; options.loaderExtension.setUVTransformToTexture) {
        options.loaderExtension.setUVTransformToTexture(texture, samplerJson);
      }

      let promise = texture.generateTextureFromUri(textureUri, false);
      textures[textureName] = texture;
      promisesToLoadResources.push(promise);

    }

    if (promisesToLoadResources.length &gt; 0) {
      Promise.resolve()
        .then(() =&gt; {
          return Promise.all(promisesToLoadResources);
        })
        .then(() =&gt; {
          this._IterateNodeOfScene(glBoostContext, buffers, json, defaultShader, shaders, textures, glTFVer, resolve, options);
        });
    } else {
      this._IterateNodeOfScene(glBoostContext, buffers, json, defaultShader, shaders, textures, glTFVer, resolve, options);
    }

    

  }

  _IterateNodeOfScene(glBoostContext, buffers, json, defaultShader, shaders, textures, glTFVer, resolve, options) {

    let rootGroup = glBoostContext.createGroup();
    rootGroup.userFlavorName = &apos;glTFFileRoot&apos;;

    for (let sceneStr in json.scenes) {
      let sceneJson = json.scenes[sceneStr];
      let group = glBoostContext.createGroup();
      group.userFlavorName = &apos;Scene_&apos; + sceneStr;
      let nodeStr = null;
      for (let i = 0; i &lt; sceneJson.nodes.length; i++) {
        nodeStr = sceneJson.nodes[i];

        // iterate nodes and load meshes
        let element = this._recursiveIterateNode(glBoostContext, nodeStr, buffers, json, defaultShader, shaders, textures, glTFVer, options);
        group.addChild(element);
      }

      // register joints hierarchy to skeletal mesh
      let skeletalMeshes = group.searchElementsByType(M_SkeletalMesh);
      skeletalMeshes.forEach((skeletalMesh) =&gt; {
        let rootJointGroup = group.searchElementByNameAndType(skeletalMesh.rootJointName, M_Group);
        if (!rootJointGroup) {
          // This is a countermeasure when skeleton node does not exist in scene.nodes.
          rootJointGroup = this._recursiveIterateNode(glBoostContext, skeletalMesh.rootJointName, buffers, json, defaultShader, shaders, textures, glTFVer, options);
          group.addChild(rootJointGroup);
        }

        rootJointGroup._isRootJointGroup = true;
        skeletalMesh.jointsHierarchy = rootJointGroup;
      });

      // Animation
      this._loadAnimation(group, buffers, json, glTFVer, options);

      rootGroup.addChild(group);

    }

    rootGroup.allMeshes = rootGroup.searchElementsByType(M_Mesh);

    if (options &amp;&amp; options.loaderExtension &amp;&amp; options.loaderExtension.setAssetPropertiesToRootGroup) {
      options.loaderExtension.setAssetPropertiesToRootGroup(rootGroup, json.asset);
    }
    if (options &amp;&amp; options.loaderExtension &amp;&amp; options.loaderExtension.loadExtensionInfoAndSetToRootGroup) {
      options.loaderExtension.loadExtensionInfoAndSetToRootGroup(rootGroup, json, glBoostContext);
    }

    resolve(rootGroup);
  }

  _setTransform(element, nodeJson) {
    if (nodeJson.translation) {
      element.translate = new Vector3(nodeJson.translation[0], nodeJson.translation[1], nodeJson.translation[2]);
    }
    if (nodeJson.scale) {
      element.scale = new Vector3(nodeJson.scale[0], nodeJson.scale[1], nodeJson.scale[2]);
    }
    if (nodeJson.rotation) {
      element.quaternion = new Quaternion(nodeJson.rotation[0], nodeJson.rotation[1], nodeJson.rotation[2], nodeJson.rotation[3]);
    }
    if (nodeJson.matrix) {
      element.matrix = new Matrix44(nodeJson.matrix, true);
    }
  }

  _recursiveIterateNode(glBoostContext, nodeStr, buffers, json, defaultShader, shaders, textures, glTFVer, options) {
    var nodeJson = json.nodes[nodeStr];
    var group = glBoostContext.createGroup();
    group.userFlavorName = nodeStr;

    this._setTransform(group, nodeJson);

    if (nodeJson.meshes) {
      for (let i = 0; i &lt; nodeJson.meshes.length; i++) {
        // this node has mashes...
        let meshStr = nodeJson.meshes[i];
        let meshJson = json.meshes[meshStr];

        let rootJointStr = null;
        let skinStr = null;
        if (nodeJson.skeletons) {
          rootJointStr = nodeJson.skeletons[0];
          skinStr = nodeJson.skin;
        }
        this._loadMesh(glBoostContext, meshJson, meshStr, buffers, json, defaultShader, rootJointStr, skinStr, shaders, textures, glTFVer, group, options);
      }
    } else if (nodeJson.jointName) {
      let joint = glBoostContext.createJoint(options.isExistJointGizmo);
      joint.userFlavorName = nodeJson.jointName;
      group.addChild(joint);
    } else if (nodeJson.camera) {
      let cameraStr = nodeJson.camera;
      let cameraJson = json.cameras[cameraStr];
      let camera = null;

      let centerVec = new Vector3(0.0, 0.0, -1.0);
      if (json.asset &amp;&amp; json.asset.LastSaved_ApplicationVendor) {
        // For backwards compatibility
        centerVec = new Vector3(1.0, 0.0, 0.0);
      }
      if (cameraJson.type === &apos;perspective&apos;) {
        let perspective = cameraJson.perspective;
        camera = glBoostContext.createPerspectiveCamera(
          {
            eye: new Vector3(0.0, 0.0, 0),
            center: centerVec,
            up: new Vector3(0.0, 1.0, 0.0)
          },
          {
            fovy: MathUtil.radianToDegree(perspective.yfov),
            aspect: perspective.aspectRatio ? perspective.aspectRatio : 1.5,
            zNear: perspective.znear,
            zFar: perspective.zfar
          }
        );
      } else if (cameraJson.type === &apos;orthographic&apos;) {
        let orthographic = cameraJson.orthographic;
        camera = glBoostContext.createOrthoCamera(
          {
            eye: new Vector3(0.0, 0.0, 0),
            center: centerVec,
            up: new Vector3(0.0, 1.0, 0.0)
          },
          {
            xmag: orthographic.xmag,
            ymag: orthographic.ymag,
            zNear: orthographic.znear,
            zFar: orthographic.zfar
          }
        );
      }
      camera.userFlavorName = cameraStr + &apos;Shape&apos;;
      group.addChild(camera);
    } else if (nodeJson.extensions) {
      if (nodeJson.extensions.KHR_materials_common) {
        if (nodeJson.extensions.KHR_materials_common.light) {
          const lightStr = nodeJson.extensions.KHR_materials_common.light
          const lightJson = json.extensions.KHR_materials_common.lights[lightStr];
          let light = null;
          if (lightJson.type === &apos;ambient&apos;) {
            let color = lightJson.ambient.color;
            light = glBoostContext.createAmbientLight(new Vector3(color[0], color[1], color[2]));
            group.addChild(light);
          } else if (lightJson.type === &apos;point&apos;) {
            let color = lightJson.point.color;
            light = glBoostContext.createPointLight(new Vector3(color[0], color[1], color[2]));
            this._setTransform(group, nodeJson);
            group.addChild(light);
          } else if (lightJson.type === &apos;directional&apos;) {
            const color = lightJson.directional.color;
            light = glBoostContext.createDirectionalLight(new Vector3(color[0], color[1], color[2]));
            light.rotate = new Vector3(0, 0, 0);
            this._setTransform(group, nodeJson);
            group.addChild(light);
          } else if (lightJson.type === &apos;spot&apos;) {
            const color = lightJson.spot.color;
            light = glBoostContext.createSpotLight(new Vector3(color[0], color[1], color[2]));
            light.rotate = new Vector3(0, 0, 0);
            if (lightJson.spot.falloffAngle) {
              light.spotCutoffInDegree = lightJson.spot.falloffAngle * 180 / Math.PI;
            }
            this._setTransform(group, nodeJson);
            group.addChild(light);
          }
        }
      }
    }

    if (nodeJson.children) {
      for (let i = 0; i &lt; nodeJson.children.length; i++) {
        let nodeStr = nodeJson.children[i];
        let childElement = this._recursiveIterateNode(glBoostContext, nodeStr, buffers, json, defaultShader, shaders, textures, glTFVer, options);
        group.addChild(childElement);
      }
    }

    return group;
  }

  _loadMesh(glBoostContext, meshJson, meshStr, buffers, json, defaultShader, rootJointStr, skinStr, shaders, textures, glTFVer, group, options) {
    var mesh = null;
    var geometry = null;
    if (rootJointStr) {
      geometry = glBoostContext.createSkeletalGeometry();
      mesh = glBoostContext.createSkeletalMesh(geometry, null, rootJointStr);
      let skin = json.skins[skinStr];

      mesh.bindShapeMatrix = new Matrix44(skin.bindShapeMatrix, true);
      mesh.jointNames = skin.jointNames;

      let inverseBindMatricesAccessorStr = skin.inverseBindMatrices;
      mesh.inverseBindMatrices = this._accessBinary(inverseBindMatricesAccessorStr, json, buffers);
    } else {
      geometry = glBoostContext.createGeometry();
      mesh = glBoostContext.createMesh(geometry);
    }
    mesh.userFlavorName = meshStr;

    if (!(options.ignoreMeshList != null) || options.ignoreMeshList.indexOf(mesh.userFlavorName) === -1) {
      // if the mesh name is not in ignore list, add it to the group.
      group.addChild(mesh);
    }

    if (options &amp;&amp; options.isMeshTransparentAsDefault || options &amp;&amp; options.defaultStates &amp;&amp; options.defaultStates.isTransparent) {
      mesh.isTransparent = true;
    }

    let _indicesArray = [];
    let _positions = [];
    let _normals = [];
    let vertexData = {
      position: _positions,
      normal: _normals,
      components: {},
      componentBytes: {},
      componentType: {}
    };
    let additional = {
      &apos;joint&apos;: [],
      &apos;weight&apos;: [],
      &apos;texcoord&apos;: [],
      &apos;color&apos;: []
    };

    let dataViewMethodDic = {};

    let materials = [];
    let indicesAccumulatedLength = 0;
    for (let i = 0; i &lt; meshJson.primitives.length; i++) {
      let primitiveJson = meshJson.primitives[i];

      // Geometry
      let positionsAccessorStr = primitiveJson.attributes.POSITION;
      let positions = this._accessBinary(positionsAccessorStr, json, buffers, false, true);
      _positions[i] = positions;
      vertexData.components.position = this._checkComponentNumber(positionsAccessorStr, json);
      vertexData.componentBytes.position = this._checkBytesPerComponent(positionsAccessorStr, json);
      vertexData.componentType.position = this._getDataType(positionsAccessorStr, json);
      dataViewMethodDic.position = this._checkDataViewMethod(positionsAccessorStr, json);


      let indices = null;
      if (typeof primitiveJson.indices !== &apos;undefined&apos;) {
        let indicesAccessorStr = primitiveJson.indices;
        indices = this._accessBinary(indicesAccessorStr, json, buffers);
        for (let j=0; j&lt;indices.length; j++) {
          indices[j] = indicesAccumulatedLength + indices[j];
        }
        _indicesArray[i] = indices;
        indicesAccumulatedLength += _positions[i].length /  vertexData.components.position;
      }


      let normalsAccessorStr = primitiveJson.attributes.NORMAL;
      if (normalsAccessorStr) {
        let normals = this._accessBinary(normalsAccessorStr, json, buffers, false, true);
        //Array.prototype.push.apply(_normals, normals);
        _normals[i] = normals;
        vertexData.components.normal = this._checkComponentNumber(normalsAccessorStr, json);
        vertexData.componentBytes.normal = this._checkBytesPerComponent(normalsAccessorStr, json);
        vertexData.componentType.normal = this._getDataType(normalsAccessorStr, json);
        dataViewMethodDic.normal = this._checkDataViewMethod(normalsAccessorStr, json);
      }

      let colorsAccessorStr = primitiveJson.attributes.COLOR;
      if (colorsAccessorStr) {
        let colors = this._accessBinary(colorsAccessorStr, json, buffers, false, true);
        additional[&apos;color&apos;][i] = colors;
        vertexData.components.color = this._checkComponentNumber(colorsAccessorStr, json);
        vertexData.componentBytes.color = this._checkBytesPerComponent(colorsAccessorStr, json);
        vertexData.componentType.color = this._getDataType(normalsAccessocolorsAccessorStrrStr, json);
        dataViewMethodDic.color = this._checkDataViewMethod(colorsAccessorStr, json);
      }

      /// if Skeletal
      let jointAccessorStr = primitiveJson.attributes.JOINT;
      if (jointAccessorStr) {
        let joints = this._accessBinary(jointAccessorStr, json, buffers, false, true);
        additional[&apos;joint&apos;][i] = joints;
        vertexData.components.joint = this._checkComponentNumber(jointAccessorStr, json);
        vertexData.componentBytes.joint = this._checkBytesPerComponent(jointAccessorStr, json);
        vertexData.componentType.joint = this._getDataType(jointAccessorStr, json);
        dataViewMethodDic.joint = this._checkDataViewMethod(jointAccessorStr, json);
      }
      let weightAccessorStr = primitiveJson.attributes.WEIGHT;
      if (weightAccessorStr) {
        let weights = this._accessBinary(weightAccessorStr, json, buffers, false, true);
        additional[&apos;weight&apos;][i] = weights;
        vertexData.components.weight = this._checkComponentNumber(weightAccessorStr, json);
        vertexData.componentBytes.weight = this._checkBytesPerComponent(weightAccessorStr, json);
        vertexData.componentType.weight = this._getDataType(weightAccessorStr, json);
        dataViewMethodDic.weight = this._checkDataViewMethod(weightAccessorStr, json);
      }

      // Material
      if (primitiveJson.material) {
        var texcoords = null;
        let texcoords0AccessorStr = primitiveJson.attributes.TEXCOORD_0;

        let materialStr = primitiveJson.material;

        /*
        let materialJson = json.materials[materialStr];

        let material = null;
        for (let mat of this._materials) {
          if (mat.userFlavorName === materialJson.name) {
            material = mat;
          }
        }
*/
        let material = null;
        if (options.defaultMaterial != null) {
          material = new options.defaultMaterial(glBoostContext.__system);
        } else if (options &amp;&amp; options.loaderExtension &amp;&amp; options.loaderExtension.createClassicMaterial) {
          material = options.loaderExtension.createClassicMaterial(glBoostContext);
        } else {
          material = glBoostContext.createClassicMaterial();
        }
        if (options &amp;&amp; options.isNeededToMultiplyAlphaToColorOfPixelOutput) {
          material.shaderParameters.isNeededToMultiplyAlphaToColorOfPixelOutput = options.isNeededToMultiplyAlphaToColorOfPixelOutput;
        }
        this._materials.push(material);

        if (options &amp;&amp; options.defaultStates) {
          if (options.defaultStates.states) {
            material.states = options.defaultStates.states;
          }
          material.globalStatesUsage = options.defaultStates.globalStatesUsage !== void 0 ? options.defaultStates.globalStatesUsage : GLBoost.GLOBAL_STATES_USAGE_IGNORE;
        }
        if (options &amp;&amp; options.statesOfElements) {

          for (let statesInfo of options.statesOfElements) {
            if (statesInfo.targets) {
              for (let target of statesInfo.targets) {
                let isMatch = this.isTargetMatch(statesInfo, group, target);
                if (isMatch) {
                  if (statesInfo.states) {
                    material.states = statesInfo.states;
                  }
                  material.globalStatesUsage = statesInfo.globalStatesUsage !== void 0 ? statesInfo.globalStatesUsage : GLBoost.GLOBAL_STATES_USAGE_IGNORE;  
                }

                group.getChildren().forEach((elem)=&gt;{
                  let isMatch = this.isTargetMatch(statesInfo, elem, target);
                  if (isMatch) {
                    elem.isTransparent = statesInfo.isTransparent !== void 0 ? statesInfo.isTransparent : false;
                    if (statesInfo.states) {
                      material.states = statesInfo.states;
                    }
                    material.globalStatesUsage = statesInfo.globalStatesUsage !== void 0 ? statesInfo.globalStatesUsage : GLBoost.GLOBAL_STATES_USAGE_IGNORE;  
                  }
                });
              }
            }
          }
        }

        texcoords = this._loadMaterial(glBoostContext, buffers, json, vertexData, indices, material, materialStr, positions, dataViewMethodDic, additional, texcoords, texcoords0AccessorStr, geometry, defaultShader, shaders, textures, i, glTFVer, group, options);

        materials.push(material);
      } else {
        let material = null;
        if (options.loaderExtension &amp;&amp; options.loaderExtension.createClassicMaterial) {
          material = options.loaderExtension.createClassicMaterial(glBoostContext);
        } else {
          material = glBoostContext.createClassicMaterial();
        }
        if (defaultShader) {
          material.shaderClass = defaultShader;
        } else {
          material.baseColor = new Vector4(0.5, 0.5, 0.5, 1);
        }
        materials.push(material);
      }

    }

    if (meshJson.primitives.length &gt; 1) {
      let lengthDic = {index: 0, position: 0, normal: 0, color: 0, joint: 0, weight: 0, texcoord: 0};
      for (let i = 0; i &lt; meshJson.primitives.length; i++) {
        //lengthDic.index += _indicesArray[i].length;
        lengthDic.position += _positions[i].length;
        if (_normals[i]) {
          lengthDic.normal += _normals[i].length;
        }
        if (typeof additional[&apos;color&apos;][i] !== &apos;undefined&apos;) {
          lengthDic.color += additional[&apos;color&apos;][i].length;
        }
        if (typeof additional[&apos;joint&apos;][i] !== &apos;undefined&apos;) {
          lengthDic.joint += additional[&apos;joint&apos;][i].length;
        }
        if (typeof additional[&apos;weight&apos;][i] !== &apos;undefined&apos;) {
          lengthDic.weight += additional[&apos;weight&apos;][i].length;
        }
        if (typeof additional[&apos;texcoord&apos;][i] !== &apos;undefined&apos;) {
          lengthDic.texcoord += additional[&apos;texcoord&apos;][i].length;
        }
      }

      function getTypedArray(dataViewMethod, length) {
        let vertexAttributeArray = null;
        if (dataViewMethod === &apos;getInt8&apos;) {
          vertexAttributeArray = new Int8Array(length);
        } else if (dataViewMethod === &apos;getUint8&apos;) {
          vertexAttributeArray = new Uint8Array(length);
        } else if (dataViewMethod === &apos;getInt16&apos;) {
          vertexAttributeArray = new Int16Array(length);
        } else if (dataViewMethod === &apos;getUint16&apos;) {
          vertexAttributeArray = new Uint16Array(length);
        } else if (dataViewMethod === &apos;getInt32&apos;) {
          vertexAttributeArray = new Int32Array(length);
        } else if (dataViewMethod === &apos;getUint32&apos;) {
          vertexAttributeArray = new Uint32Array(length);
        } else if (dataViewMethod === &apos;getFloat32&apos;) {
          vertexAttributeArray = new Float32Array(length);
        }

        return vertexAttributeArray;
      }

      for (let attribName in dataViewMethodDic) {
        let newTypedArray = getTypedArray(dataViewMethodDic[attribName], lengthDic[attribName]);
        let offset = 0;
        for (let i = 0; i &lt; meshJson.primitives.length; i++) {

          let array = null;

          if (attribName === &apos;position&apos;) {
            array = _positions[i];
          } else if (attribName === &apos;normal&apos;) {
            array = _normals[i];
          } else if (attribName === &apos;color&apos;) {
            array = additional[&apos;color&apos;][i];
          } else if (attribName === &apos;joint&apos;) {
            array = additional[&apos;joint&apos;][i];
          } else if (attribName === &apos;weight&apos;) {
            array = additional[&apos;weight&apos;][i];
          } else if (attribName === &apos;texcoord&apos;) {
            array = additional[&apos;texcoord&apos;][i];
          }

          if (array) {
            newTypedArray.set(array, offset);
            offset += array.length;
          }
        }

        if (attribName === &apos;position&apos;) {
          vertexData.position = newTypedArray;
        } else if (attribName === &apos;normal&apos;) {
          vertexData.normal = newTypedArray;
        } else if (attribName === &apos;color&apos;) {
          additional[&apos;color&apos;] = newTypedArray;
        } else if (attribName === &apos;joint&apos;) {
          additional[&apos;joint&apos;] = newTypedArray;
        } else if (attribName === &apos;weight&apos;) {
          additional[&apos;weight&apos;] = newTypedArray;
        } else if (attribName === &apos;texcoord&apos;) {
          additional[&apos;texcoord&apos;] = newTypedArray;
        }
      }


    } else {
      vertexData.position = _positions[0];
      vertexData.normal = _normals[0];
      additional[&apos;color&apos;] = additional[&apos;color&apos;][0];
      additional[&apos;joint&apos;] = additional[&apos;joint&apos;][0];
      additional[&apos;weight&apos;] = additional[&apos;weight&apos;][0];
      additional[&apos;texcoord&apos;] = additional[&apos;texcoord&apos;][0];
    }

    if (typeof vertexData.normal === &apos;undefined&apos; || vertexData.normal.length === 0) {
      delete vertexData.normal;
    }
    if (typeof additional[&apos;color&apos;] === &apos;undefined&apos; || additional[&apos;color&apos;].length === 0) {
      delete additional[&apos;color&apos;];
    }
    if (typeof additional[&apos;joint&apos;] === &apos;undefined&apos; || additional[&apos;joint&apos;].length === 0) {
      delete additional[&apos;joint&apos;];
    }
    if (typeof additional[&apos;weight&apos;] === &apos;undefined&apos; || additional[&apos;weight&apos;].length === 0) {
      delete additional[&apos;weight&apos;];
    }
    if (typeof additional[&apos;texcoord&apos;] === &apos;undefined&apos; || additional[&apos;texcoord&apos;].length === 0) {
      delete additional[&apos;texcoord&apos;];
    }


    if (_indicesArray.length === 0) {
      _indicesArray = null;
    }

    geometry.setVerticesData(ArrayUtil.merge(vertexData, additional), _indicesArray);
    geometry.materials = materials;

    return mesh;
  }

  _isKHRMaterialsCommon(materialJson) {
    if (typeof materialJson.extensions !== &apos;undefined&apos; &amp;&amp; typeof materialJson.extensions.KHR_materials_common !== &apos;undefined&apos;) {
      return true;
    } else {
      return false;
    }
  }

  _loadMaterial(glBoostContext, buffers, json, vertexData, indices, material, materialStr, positions, dataViewMethodDic, additional, texcoords, texcoords0AccessorStr, geometry, defaultShader, shaders, textures, idx, glTFVer, group, options) {
    let materialJson = json.materials[materialStr];
    material.userFlavorName = materialJson.name;
    let originalMaterialJson = materialJson;
    
    if (this._isKHRMaterialsCommon(materialJson)) {
      materialJson = materialJson.extensions.KHR_materials_common;
    }


    let enables = [];
    if (options.isBlend) {
      enables.push(3042);
    }
    if (options.isDepthTest) {
      enables.push(2929);
    }
    material.states.enable = material.states.enable.concat(enables);

    // Remove duplicated values
    material.states.enable = material.states.enable.filter(function (x, i, self) {
      return self.indexOf(x) === i;
    });

    if (options &amp;&amp; options.statesOfElements) {
      for (let statesInfo of options.statesOfElements) {
        if (statesInfo.opacity) {
          group.opacity = statesInfo.opacity;
        }
      }
    }

    if (options.isBlend &amp;&amp; options.isNeededToMultiplyAlphaToColorOfPixelOutput) {
      if (material.states.functions.blendFuncSeparate === void 0) {
        material.states.functions.blendFuncSeparate = [1, 771, 1, 771];
      }
    }
    material.globalStatesUsage = GLBoost.GLOBAL_STATES_USAGE_IGNORE;

  
    // Diffuse Texture
    if (texcoords0AccessorStr) {
      texcoords = this._accessBinary(texcoords0AccessorStr, json, buffers, false, true);
      additional[&apos;texcoord&apos;][idx] = texcoords;
      vertexData.components.texcoord = this._checkComponentNumber(texcoords0AccessorStr, json);
      vertexData.componentBytes.texcoord = this._checkBytesPerComponent(texcoords0AccessorStr, json);
      vertexData.componentType.texcoord = this._getDataType(texcoords0AccessorStr, json);
      dataViewMethodDic.texcoord = this._checkDataViewMethod(texcoords0AccessorStr, json);

      let setTextures = (values, isParameter)=&gt; {
        for (let valueName in values) {
          let value = null;
          if (isParameter) {
            value = values[valueName].value;
            if (typeof value === &apos;undefined&apos;) {
              continue;
            }
          } else {
            value = values[valueName];
          }
          if (glTFVer &gt;= 1.1) {
            value = value[0];
          }
          if (typeof value === &apos;string&apos;) {
            let textureStr = value;
            let texturePurpose;
            if (valueName === &apos;diffuse&apos; || (materialJson.technique === &quot;CONSTANT&quot; &amp;&amp; valueName === &apos;ambient&apos;)) {
              texturePurpose = GLBoost.TEXTURE_PURPOSE_DIFFUSE;
            } else if (valueName === &apos;emission&apos; &amp;&amp; textureStr.match(/_normal$/)) {
              texturePurpose = GLBoost.TEXTURE_PURPOSE_NORMAL;
            } else {
              texturePurpose = GLBoost.TEXTURE_PURPOSE_OTHERS;
            }

            let texture = textures[textureStr];
            
            let isNeededToMultiplyAlphaToColorOfTexture = false;

            if (options.isNeededToMultiplyAlphaToColorOfPixelOutput) {
              if (options.isTextureImageToLoadPreMultipliedAlphaAsDefault) {
                // Nothing to do because premultipling alpha is already done.
              } else {
                isNeededToMultiplyAlphaToColorOfTexture = true;
              }
            } else { // if is NOT Needed To Multiply AlphaToColor Of PixelOutput
              if (options.isTextureImageToLoadPreMultipliedAlphaAsDefault) {
                // TODO: Implement to Make Texture Straight.
              } else {
                // Nothing to do because the texture is straight.
              }
            }

            if (options &amp;&amp; options.statesOfElements) {
              for (let statesInfo of options.statesOfElements) {
                if (statesInfo.targets) {
                  for (let target of statesInfo.targets) {
                    let isMatch = false;
                    isMatch = this.isTargetMatch(statesInfo, group, target);

                    if (isMatch) {
                      if (options.isNeededToMultiplyAlphaToColorOfPixelOutput) {
                        if (statesInfo.isTextureImageToLoadPreMultipliedAlpha) {
                          // Nothing to do because premultipling alpha is already done.
                        } else {
                          isNeededToMultiplyAlphaToColorOfTexture = true;
                        }
                      } else { // if is NOT Needed To Multiply AlphaToColor Of PixelOutput
                        if (statesInfo.isTextureImageToLoadPreMultipliedAlpha) {
                          // TODO: Implement to Make Texture Straight.
                        } else {
                          // Nothing to do because the texture is straight.
                        }
                      }
                    }

                    //texture.setParameter(&apos;UNPACK_PREMULTIPLY_ALPHA_WEBGL&apos;, isNeededToMultiplyAlphaToColorOfTexture);
//                    texture.loadWebGLTexture();
                  }
                }
              }
            }

            material.setTexture(texture, texturePurpose);
            texture.toMultiplyAlphaToColorPreviously = isNeededToMultiplyAlphaToColorOfTexture;
          }
        }
      };
      setTextures(materialJson.values, false);
      if (materialJson.technique &amp;&amp; json.techniques) {
        if (typeof json.techniques[materialJson.technique] !== &quot;undefined&quot;) {
          setTextures(json.techniques[materialJson.technique].parameters, true);
        }
      }

    } else {
      if (typeof vertexData.components.texcoord !== &apos;undefined&apos;) {
        // If texture coordinates existed even once in the previous loop
        let emptyTexcoords = [];
        let componentN = vertexData.components.position;
        let length = positions.length / componentN;
        for (let k = 0; k &lt; length; k++) {
          emptyTexcoords.push(0);
          emptyTexcoords.push(0);
        }
        additional[&apos;texcoord&apos;][idx] = new Float32Array(emptyTexcoords);
        vertexData.components.texcoord = 2;
        vertexData.componentBytes.texcoord = 4;
        dataViewMethodDic.texcoord = &apos;getFloat32&apos;;
      }
    }

    for (let valueName in materialJson.values) {
      let value = materialJson.values[valueName];
      if (typeof value !== &apos;string&apos;) {
        material[valueName + &apos;Color&apos;] = MathClassUtil.arrayToVectorOrMatrix(value);
      }
      if (valueName === &apos;transparent&apos;) {
        material.isTransparent = value;
        let enables = [3042];
        material.states.enable = material.states.enable.concat(enables);
      }
      if (valueName === &apos;transparency&apos;) {
        material.baseColor.w = 1.0 - value;
        material.diffuseColor.w = 1.0 - value;
        material.specularColor.w = 1.0 - value;
        material.ambientColor.w = 1.0 - value;
      }
    }

    if (indices !== null) {
      material.setVertexN(geometry, indices.length);
    }

    let techniqueStr = materialJson.technique;
    if (defaultShader) {
      material.shaderClass = defaultShader;
    } else if (this._isKHRMaterialsCommon(originalMaterialJson) &amp;&amp; material.className.indexOf(&apos;PBR&apos;) === -1) {
      switch (techniqueStr) {
        case &apos;CONSTANT&apos;:
          if (options.loaderExtension &amp;&amp; options.loaderExtension.getDecalShader) {
            material.shaderClass = options.loaderExtension.getDecalShader();
          } else {
            material.shaderClass = DecalShader;
          }
          break;
        case &apos;LAMBERT&apos;:
          if (options.loaderExtension &amp;&amp; options.loaderExtension.getLambertShader) {
            material.shaderClass = options.loaderExtension.getLambertShader();
          } else {
            material.shaderClass = LambertShader;
          }
          break;
        case &apos;PHONG&apos;:
          if (options.loaderExtension &amp;&amp; options.loaderExtension.getPhongShader) {
            material.shaderClass = options.loaderExtension.getPhongShader();
          } else {
            material.shaderClass = PhongShader;
          }
          break;
      }
    } else {
      if (typeof json.techniques !== &apos;undefined&apos;) {
        this._loadTechnique(glBoostContext, json, techniqueStr, material, materialJson, shaders, glTFVer);
      } else if (material.className.indexOf(&apos;PBR&apos;) === -1) {
        if (options.loaderExtension &amp;&amp; options.loaderExtension.getDecalShader) {
          material.shaderClass = options.loaderExtension.getDecalShader();
        } else {
          material.shaderClass = DecalShader;
        }
      }
    }

    if (options &amp;&amp; options.statesOfElements) {
      for (let statesInfo of options.statesOfElements) {
        if (statesInfo.targets) {
          for (let target of statesInfo.targets) {
            let isMatch = false;
            isMatch = this.isTargetMatch(statesInfo, group, target);

            if (isMatch) {
              if (statesInfo.shaderClass) {
                material.shaderClass = statesInfo.shaderClass;
              }
            }

          }
        }
      }
    }

    return texcoords;
  }

  isTargetMatch(statesInfo, element, target) {
    let specifyMethod = statesInfo.specifyMethod !== void 0 ? statesInfo.specifyMethod : GLBoost.QUERY_TYPE_USER_FLAVOR_NAME;
    if (typeof statesInfo.specifyMethod === &apos;string&apos;) {
      statesInfo.specifyMethod = GLBoost[statesInfo.specifyMethod];
    }

    const isTargetMatchInner = function(specifyMethod, element, target) {
      let isMatch = false;
      switch (specifyMethod) {
      case GLBoost.QUERY_TYPE_USER_FLAVOR_NAME:
        isMatch = element.userFlavorName === target;
        break;
      case GLBoost.QUERY_TYPE_INSTANCE_NAME:
        isMatch = element.instanceName === target;
        break;
      case GLBoost.QUERY_TYPE_INSTANCE_NAME_WITH_USER_FLAVOR:
        isMatch = element.instanceNameWithUserFlavor === target;
        break;
      }
      return isMatch;
    };

    let isMatch = isTargetMatchInner(specifyMethod, element, target);

    return isMatch;
  }

  _loadTechnique(glBoostContext, json, techniqueStr, material, materialJson, shaders, glTFVer) {
    let techniqueJson = json.techniques[techniqueStr];


    let programStr = techniqueJson.program;
    let uniformsJson = techniqueJson.uniforms;
    let parametersJson = techniqueJson.parameters;
    let attributesJson = techniqueJson.attributes;
    let attributes = {};
    for (let attributeName in attributesJson) {
      //attributes[attributesJson[attributeName]] = attributeName;
      let parameterName = attributesJson[attributeName];
      let parameterJson = parametersJson[parameterName];
      attributes[attributeName] = parameterJson.semantic;
    }

    let uniforms = {};
    let textureNames = {};
    for (let uniformName in uniformsJson) {
      let parameterName = uniformsJson[uniformName];
      let parameterJson = parametersJson[parameterName];
      if (typeof parameterJson.semantic !== &apos;undefined&apos;) {
        uniforms[uniformName] = parameterJson.semantic;
      } else {
        let value = null;
        if (typeof materialJson.values !== &apos;undefined&apos; &amp;&amp; typeof materialJson.values[parameterName] !== &apos;undefined&apos;) {
          value = materialJson.values[parameterName];
        } else {
          value = parameterJson.value;
        }

        switch (parameterJson.type) {
          case 5126:
            uniforms[uniformName] = (glTFVer &lt; 1.1) ? value : value[0];
            break;
          case 35664:
            uniforms[uniformName] = new Vector2(value[0], value[1]);
            break;
          case 35665:
            uniforms[uniformName] = new Vector3(value[0], value[1], value[2]);
            break;
          case 35666:
            uniforms[uniformName] = new Vector4(value[0], value[1], value[2], value[3]);
            break;
          case 5124:
            uniforms[uniformName] = (glTFVer &lt; 1.1) ? value : value[0];
            break;
          case 35667:
            uniforms[uniformName] = new Vector2(value[0], value[1]);
            break;
          case 35668:
            uniforms[uniformName] = new Vector3(value[0], value[1], value[2]);
            break;
          case 35669:
            uniforms[uniformName] = new Vector4(value[0], value[1], value[2], value[3]);
            break;
          case 35678:
            uniforms[uniformName] = &apos;TEXTURE&apos;;
            textureNames[uniformName] =  (glTFVer &lt; 1.1) ? value : value[0];
            break;
        }
      }
    }

    if (techniqueJson.states) {
      if (techniqueJson.states.functions) {
        for (let functionName in techniqueJson.states.functions) {
          if (!Array.isArray(techniqueJson.states.functions[functionName])) {
            techniqueJson.states.functions[functionName] = [techniqueJson.states.functions[functionName]];
          }
        }
      }

      material.states = techniqueJson.states;
    }

    this._loadProgram(glBoostContext, json, programStr, material, shaders, attributes, uniforms, textureNames);
  }



  _loadProgram(glBoostContext, json, programStr, material, shaders, attributes, uniforms, textureNames) {
    let programJson = json.programs[programStr];
    let fragmentShaderStr = programJson.fragmentShader;
    let vertexShaderStr = programJson.vertexShader;
    let fragmentShaderText = shaders[fragmentShaderStr].shaderText;
    let vertexShaderText = shaders[vertexShaderStr].shaderText;

    material.shaderInstance = new FreeShader(glBoostContext.__system, vertexShaderText, fragmentShaderText, attributes, uniforms, textureNames);
  }

  _loadAnimation(element, buffers, json, glTFVer, options) {
    let animationJson = null;
    for (let anim in json.animations) {
      animationJson = json.animations[anim];
      if (animationJson) {
        for (let i = 0; i &lt; animationJson.channels.length; i++) {
          let channelJson = animationJson.channels[i];
          if (!channelJson) {
            continue;
          }

          let targetMeshStr = channelJson.target.id;
          let targetPathStr = channelJson.target.path;
          let samplerStr = channelJson.sampler;
          let samplerJson = animationJson.samplers[samplerStr];

          let animInputAccessorStr = null;
          let animOutputAccessorStr = null;
          let animInputStr = samplerJson.input;
          let animOutputStr = samplerJson.output;
          animInputAccessorStr = animationJson.parameters[animInputStr];
          animOutputAccessorStr = animationJson.parameters[animOutputStr];

          let interpolationMethod = GLBoost.INTERPOLATION_LINEAR;

          if (options.loaderExtension &amp;&amp; options.loaderExtension.getAnimationInterpolationMethod) {
            interpolationMethod = options.loaderExtension.getAnimationInterpolationMethod(samplerJson.interpolation);
          }

          let animInputArray = this._accessBinary(animInputAccessorStr, json, buffers);
          let animOutputArray = null;
          if (targetPathStr === &apos;translation&apos;) {
            animOutputArray = this._accessBinary(animOutputAccessorStr, json, buffers);
          } else if (targetPathStr === &apos;rotation&apos;) {
            animOutputArray = this._accessBinary(animOutputAccessorStr, json, buffers, true);
          } else {
            animOutputArray = this._accessBinary(animOutputAccessorStr, json, buffers);
          }
          let animationAttributeName = &apos;&apos;;
          if (targetPathStr === &apos;translation&apos;) {
            animationAttributeName = &apos;translate&apos;;
          } else if (targetPathStr === &apos;rotation&apos;) {
            animationAttributeName = &apos;quaternion&apos;;
          } else {
            animationAttributeName = targetPathStr;
          }


          let hitElement = element.searchElement(targetMeshStr);
          if (hitElement) {
            hitElement.setAnimationAtLine(&apos;time&apos;, animationAttributeName, animInputArray, animOutputArray, interpolationMethod);
            hitElement.setActiveAnimationLine(&apos;time&apos;);
          }
        }
      }
    }
  }
  _accessBinaryAsShader(bufferViewStr, json, arrayBuffer) {
    let bufferViewJson = json.bufferViews[bufferViewStr];
    let byteOffset = bufferViewJson.byteOffset;
    let byteLength = bufferViewJson.byteLength;


    let arrayBufferSliced = arrayBuffer.slice(byteOffset, byteOffset + byteLength);

    return DataUtil.arrayBufferToString(arrayBufferSliced);
  }

  _sliceBufferViewToArrayBuffer(json, bufferViewStr, arrayBuffer) {
    let bufferViewJson = json.bufferViews[bufferViewStr];
    let byteOffset = (bufferViewJson.byteOffset != null) ? bufferViewJson.byteOffset : 0;
    let byteLength = bufferViewJson.byteLength;
    let arrayBufferSliced = arrayBuffer.slice(byteOffset, byteOffset + byteLength);
    return arrayBufferSliced;
  }

  _accessBinaryAsImage(bufferViewStr, json, arrayBuffer, mimeType) {
    let arrayBufferSliced = this._sliceBufferViewToArrayBuffer(json, bufferViewStr, arrayBuffer);
    return this._accessArrayBufferAsImage(arrayBufferSliced, mimeType);
  }

  _accessArrayBufferAsImage(arrayBuffer, imageType) {
    let bytes = new Uint8Array(arrayBuffer);
    let binaryData = &apos;&apos;;
    for (let i = 0, len = bytes.byteLength; i &lt; len; i++) {
      binaryData += String.fromCharCode(bytes[i]);
    }
    let imgSrc = &apos;&apos;;
    if (imageType === &apos;image/jpeg&apos; || imageType.toLowerCase() === &apos;jpg&apos; || imageType.toLowerCase() === &apos;jpeg&apos;) {
      imgSrc = &quot;data:image/jpeg;base64,&quot;;
    }
    else if (imageType == &apos;image/png&apos; || imageType.toLowerCase() === &apos;png&apos;) {
      imgSrc = &quot;data:image/png;base64,&quot;;
    }
    else if (imageType == &apos;image/gif&apos; || imageType.toLowerCase() === &apos;gif&apos;) {
      imgSrc = &quot;data:image/gif;base64,&quot;;
    }
    else if (imageType == &apos;image/bmp&apos; || imageType.toLowerCase() === &apos;bmp&apos;) {
      imgSrc = &quot;data:image/bmp;base64,&quot;;
    }
    else {
      imgSrc = &quot;data:image/unknown;base64,&quot;;
    }
    let dataUrl = imgSrc + DataUtil.btoa(binaryData);
    return dataUrl;
  }

  static _isSystemLittleEndian() {
    return !!(new Uint8Array((new Uint16Array([0x00ff])).buffer))[0];
  }

  _checkComponentNumber(accessorStr, json) {
    var accessorJson = json.accessors[accessorStr];

    var componentN = 0;
    switch (accessorJson.type) {
      case &apos;SCALAR&apos;:
        componentN = 1;
        break;
      case &apos;VEC2&apos;:
        componentN = 2;
        break;
      case &apos;VEC3&apos;:
        componentN = 3;
        break;
      case &apos;VEC4&apos;:
        componentN = 4;
        break;
      case &apos;MAT4&apos;:
        componentN = 16;
        break;
    }

    return componentN;
  }

  _checkBytesPerComponent(accessorStr, json) {
    var accessorJson = json.accessors[accessorStr];

    var bytesPerComponent = 0;
    switch (accessorJson.componentType) {
      case 5120: // gl.BYTE
        bytesPerComponent = 1;
        break;
      case 5121: // gl.UNSIGNED_BYTE
        bytesPerComponent = 1;
        break;
      case 5122: // gl.SHORT
        bytesPerComponent = 2;
        break;
      case 5123: // gl.UNSIGNED_SHORT
        bytesPerComponent = 2;
        break;
      case 5124: // gl.INT
        bytesPerComponent = 4;
        break;
      case 5125: // gl.UNSIGNED_INT
        bytesPerComponent = 4;
        break;
      case 5126: // gl.FLOAT
        bytesPerComponent = 4;
        break;
      default:
        break;
    }
    return bytesPerComponent;
  }

  _checkDataViewMethod(accessorStr, json) {
    var accessorJson = json.accessors[accessorStr];
    var dataViewMethod = &apos;&apos;;
    switch (accessorJson.componentType) {
      case 5120: // gl.BYTE
        dataViewMethod = &apos;getInt8&apos;;
        break;
      case 5121: // gl.UNSIGNED_BYTE
        dataViewMethod = &apos;getUint8&apos;;
        break;
      case 5122: // gl.SHORT
        dataViewMethod = &apos;getInt16&apos;;
        break;
      case 5123: // gl.UNSIGNED_SHORT
        dataViewMethod = &apos;getUint16&apos;;
        break;
      case 5124: // gl.INT
        dataViewMethod = &apos;getInt32&apos;;
        break;
      case 5125: // gl.UNSIGNED_INT
        dataViewMethod = &apos;getUint32&apos;;
        break;
      case 5126: // gl.FLOAT
        dataViewMethod = &apos;getFloat32&apos;;
        break;
      default:
        break;
    }
    return dataViewMethod;
  }

  _getDataType(accessorStr, json) {
    var accessorJson = json.accessors[accessorStr];
    return accessorJson.componentType;
  }

  _adjustByteAlign(typedArrayClass, arrayBuffer, alignSize, byteOffset, length) {
    if (( byteOffset % alignSize ) != 0) {
      return new typedArrayClass(arrayBuffer.slice(byteOffset), 0, length);
    } else {
      return new typedArrayClass(arrayBuffer, byteOffset, length);
    }
  }

  _accessBinary(accessorStr, json, buffers, quaternionIfVec4 = false, toGetAsTypedArray = false) {
    var accessorJson = json.accessors[accessorStr];
    var bufferViewStr = accessorJson.bufferView;
    var bufferViewJson = json.bufferViews[bufferViewStr];
    var byteOffset = bufferViewJson.byteOffset + accessorJson.byteOffset;
    var bufferStr = bufferViewJson.buffer;
    var arrayBuffer = buffers[bufferStr];

    let componentN = this._checkComponentNumber(accessorStr, json);
    let bytesPerComponent = this._checkBytesPerComponent(accessorStr, json);
    var dataViewMethod = this._checkDataViewMethod(accessorStr, json);


    var byteLength = bytesPerComponent * componentN * accessorJson.count;

    var vertexAttributeArray = [];

    if (toGetAsTypedArray) {
      if (GLTFLoader._isSystemLittleEndian()) {
        if (dataViewMethod === &apos;getFloat32&apos;) {
          vertexAttributeArray = this._adjustByteAlign(Float32Array, arrayBuffer, 4, byteOffset, byteLength / bytesPerComponent);
        } else if (dataViewMethod === &apos;getInt8&apos;) {
          vertexAttributeArray = new Int8Array(arrayBuffer, byteOffset, byteLength / bytesPerComponent);
        } else if (dataViewMethod === &apos;getUint8&apos;) {
          vertexAttributeArray = new Uint8Array(arrayBuffer, byteOffset, byteLength / bytesPerComponent);
        } else if (dataViewMethod === &apos;getInt16&apos;) {
          vertexAttributeArray = this._adjustByteAlign(Int16Array, arrayBuffer, 2, byteOffset, byteLength / bytesPerComponent);
        } else if (dataViewMethod === &apos;getUint16&apos;) {
          vertexAttributeArray = this._adjustByteAlign(Uint16Array, arrayBuffer, 2, byteOffset, byteLength / bytesPerComponent);
        } else if (dataViewMethod === &apos;getInt32&apos;) {
          vertexAttributeArray = this._adjustByteAlign(Int32Array, arrayBuffer, 4, byteOffset, byteLength / bytesPerComponent);
        } else if (dataViewMethod === &apos;getUint32&apos;) {
          vertexAttributeArray = this._adjustByteAlign(Uint32Array, arrayBuffer, 4, byteOffset, byteLength / bytesPerComponent);
        }

      } else {
        let dataView = new DataView(arrayBuffer, byteOffset, byteLength);
        let byteDelta = bytesPerComponent * componentN;
        let littleEndian = true;
        for (let pos = 0; pos &lt; byteLength; pos += byteDelta) {
          switch (accessorJson.type) {
            case &apos;SCALAR&apos;:
              vertexAttributeArray.push(dataView[dataViewMethod](pos, littleEndian));
              break;
            case &apos;VEC2&apos;:
              vertexAttributeArray.push(dataView[dataViewMethod](pos, littleEndian));
              vertexAttributeArray.push(dataView[dataViewMethod](pos + bytesPerComponent, littleEndian));
              break;
            case &apos;VEC3&apos;:
              vertexAttributeArray.push(dataView[dataViewMethod](pos, littleEndian));
              vertexAttributeArray.push(dataView[dataViewMethod](pos + bytesPerComponent, littleEndian));
              vertexAttributeArray.push(dataView[dataViewMethod](pos + bytesPerComponent * 2, littleEndian));
              break;
            case &apos;VEC4&apos;:
              vertexAttributeArray.push(dataView[dataViewMethod](pos, littleEndian));
              vertexAttributeArray.push(dataView[dataViewMethod](pos + bytesPerComponent, littleEndian));
              vertexAttributeArray.push(dataView[dataViewMethod](pos + bytesPerComponent * 2, littleEndian));
              vertexAttributeArray.push(dataView[dataViewMethod](pos + bytesPerComponent * 3, littleEndian));
              break;
          }
        }
        if (dataViewMethod === &apos;getInt8&apos;) {
          vertexAttributeArray = new Int8Array(vertexAttributeArray);
        } else if (dataViewMethod === &apos;getUint8&apos;) {
          vertexAttributeArray = new Uint8Array(vertexAttributeArray);
        } else if (dataViewMethod === &apos;getInt16&apos;) {
          vertexAttributeArray = new Int16Array(vertexAttributeArray);
        } else if (dataViewMethod === &apos;getUint16&apos;) {
          vertexAttributeArray = new Uint16Array(vertexAttributeArray);
        } else if (dataViewMethod === &apos;getInt32&apos;) {
          vertexAttributeArray = new Int32Array(vertexAttributeArray);
        } else if (dataViewMethod === &apos;getUint32&apos;) {
          vertexAttributeArray = new Uint32Array(vertexAttributeArray);
        } else if (dataViewMethod === &apos;getFloat32&apos;) {
          vertexAttributeArray = new Float32Array(vertexAttributeArray);
        }
      }
    } else {
      let dataView = new DataView(arrayBuffer, byteOffset, byteLength);
      let byteDelta = bytesPerComponent * componentN;
      let littleEndian = true;
      for (let pos = 0; pos &lt; byteLength; pos += byteDelta) {

        switch (accessorJson.type) {
          case &apos;SCALAR&apos;:
            vertexAttributeArray.push(dataView[dataViewMethod](pos, littleEndian));
            break;
          case &apos;VEC2&apos;:
            vertexAttributeArray.push(new Vector2(
              dataView[dataViewMethod](pos, littleEndian),
              dataView[dataViewMethod](pos+bytesPerComponent, littleEndian)
            ));
            break;
          case &apos;VEC3&apos;:
            vertexAttributeArray.push(new Vector3(
              dataView[dataViewMethod](pos, littleEndian),
              dataView[dataViewMethod](pos+bytesPerComponent, littleEndian),
              dataView[dataViewMethod](pos+bytesPerComponent*2, littleEndian)
            ));
            break;
          case &apos;VEC4&apos;:
            if (quaternionIfVec4) {
              vertexAttributeArray.push(new Quaternion(
                dataView[dataViewMethod](pos, littleEndian),
                dataView[dataViewMethod](pos+bytesPerComponent, littleEndian),
                dataView[dataViewMethod](pos+bytesPerComponent*2, littleEndian),
                dataView[dataViewMethod](pos+bytesPerComponent*3, littleEndian)
              ));
            } else {
              vertexAttributeArray.push(new Vector4(
                dataView[dataViewMethod](pos, littleEndian),
                dataView[dataViewMethod](pos+bytesPerComponent, littleEndian),
                dataView[dataViewMethod](pos+bytesPerComponent*2, littleEndian),
                dataView[dataViewMethod](pos+bytesPerComponent*3, littleEndian)
              ));
            }
            break;
          case &apos;MAT4&apos;:
            let matrixComponents = [];
            for (let i=0; i&lt;16; i++) {
              matrixComponents[i] = dataView[dataViewMethod](pos+bytesPerComponent*i, littleEndian);
            }
            vertexAttributeArray.push(new Matrix44(matrixComponents, true));
            break;
        }

      }
    }


    return vertexAttributeArray;
  }

}



GLBoost[&quot;GLTFLoader&quot;] = GLTFLoader;

</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
